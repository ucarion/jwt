package jwt

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/json"
)

const algRS256 = "RS256"

// SignRS256 takes a RSA private key and a set of claims, and returns a
// RS256-signed JWT containing those claims.
//
// VerifyRS256 can verify tokens signed by SignRS256.
//
// When using SignRS256 and VerifyRS256 in production, use an RSA keypair
// generated by a tool like OpenSSL, and use at least 2048 bits. Do not leak or
// give out the private key to any systems or people that don't need it, because
// they will be able to generate JWTs that will be indistinguishable from the
// ones you can generate yourself.
//
// RS256 is short for RSA Signature with SHA-256. It is a mechanism for message
// authentication. By signing a set of claims with SignRS256, you have not
// encrypted it. It is trivial for anyone to read the data stored in the return
// value of SignRS256. All SignRS256 gives you is a signature that proves that
// when you generated a JWT, you had a particular RSA private key on hand -- and
// it does this without giving away what the private key is. VerifyRS256 can
// verify the JWTs produced by SignRS256; to do this, it needs to use the public
// key that corresponds to the private key you used in SignHS256.
//
// The second parameter to this function, v, should be compatible with the
// encoding/json package of the standard library. The JSON representation of v
// will be used as the claims part of the returned JWT.
//
// SignRS256 will return an error only if calling json.Marshal on v returns an
// error.
func SignRS256(priv *rsa.PrivateKey, v interface{}) ([]byte, error) {
	return sign(algRS256, 256, v, func(data []byte) ([]byte, error) {
		h := crypto.SHA256.New()
		h.Write(data)

		return rsa.SignPKCS1v15(rand.Reader, priv, crypto.SHA256, h.Sum(nil))
	})
}

// VerifyRS256 verifies a JWT using a RSA public key. If the JWT is verified,
// VerifyRS256 will serialize the claims inside the JWT into v.
//
// VerifyRS256 can verify tokens signed by SignRS256.
//
// When using SignRS256 and VerifyRS256 in production, use an RSA keypair
// generated by a tool like OpenSSL, and use at least 2048 bits. Do not leak or
// give out the private key to any systems or people that don't need it, because
// they will be able to generate JWTs that will be indistinguishable from the
// ones you can generate yourself.
//
// RS256 is short for RSA Signature with SHA-256. It is a mechanism for message
// authentication. By signing a set of claims with SignRS256, you have not
// encrypted it. It is trivial for anyone to read the data stored in the return
// value of SignRS256. All SignRS256 gives you is a signature that proves that
// when you generated a JWT, you had a particular RSA private key on hand -- and
// it does this without giving away what the private key is. VerifyRS256 can
// verify the JWTs produced by SignRS256; to do this, it needs to use the public
// key that corresponds to the private key you used in SignHS256.
//
// The second parameter to this function, v, should be a pointer to something
// compatible with the encoding/json package of the standard library. If
// verification succeeds, VerifyRS256 will deserialize the claims in the JWT
// into v.
//
// VerifyRS256 will return InvalidSignature if the JWT is malformed, uses any
// algorithm other than RS256, or is not signed with the private key that
// corresponds to the public key given.
func VerifyRS256(pub *rsa.PublicKey, s []byte, v interface{}) error {
	claims, err := verify(algRS256, s, func(data, sig []byte) error {
		h := sha256.New()
		h.Write(data)

		if rsa.VerifyPKCS1v15(pub, crypto.SHA256, h.Sum(nil), sig) != nil {
			return ErrInvalidSignature
		}

		return nil
	})

	if err != nil {
		return err
	}

	return json.Unmarshal(claims, v)
}
