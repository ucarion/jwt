package jwt

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"encoding/json"
	"math/big"
)

const algES256 = "ES256"

// SignES256 takes a ECDSA private key and a set of claims, and returns a
// ES256-signed JWT containing those claims.
//
// VerifyES256 can verify tokens signed by SignES256.
//
// When using SignES256 and VerifyES256 in production, use a ECDSA keypair
// generated by a tool like OpenSSL. Do not leak or give out the private key to
// any systems or people that don't need it, because they will be able to
// generate JWTs that will be indistinguishable from the ones you can generate
// yourself.
//
// ES256 is short for Elliptic Curve Digital Signature Algorithm with SHA-256.
// It is a mechanism for message authentication. By signing a set of claims with
// SignES256, you have not encrypted it. It is trivial for anyone to read the
// data stored in the return value of SignES256. All SignES256 gives you is a
// signature that proves that when you generated a JWT, you had a particular
// ECDSA private key on hand -- and it does this without giving away what the
// private key is. VerifyES256 can verify the JWTs produced by SignES256; to do
// this, it needs to use the public key that corresponds to the private key you
// used in SignES256.
//
// The second parameter to this function, v, should be compatible with the
// encoding/json package of the standard library. The JSON representation of v
// will be used as the claims part of the returned JWT.
//
// SignES256 will return an error only if calling json.Marshal on v returns an
// error.
func SignES256(priv *ecdsa.PrivateKey, v interface{}) ([]byte, error) {
	return sign(algES256, 64, v, func(data []byte) ([]byte, error) {
		h := crypto.SHA256.New()
		h.Write(data)

		sigR, sigS, err := ecdsa.Sign(rand.Reader, priv, h.Sum(nil))
		if err != nil {
			return nil, err
		}

		sig := make([]byte, 64)

		r := sigR.Bytes()
		s := sigS.Bytes()

		copy(sig[32-len(r):], r)
		copy(sig[64-len(s):], s)

		return sig, nil
	})
}

// VerifyES256 verifies a JWT using a ECDSA public key. If the JWT is verified,
// VerifyES256 will serialize the claims inside the JWT into v.
//
// The second parameter to this function, v, should be a pointer to something
// compatible with the encoding/json package of the standard library. If
// verification succeeds, VerifyES256 will deserialize the claims in the JWT
// into v.
//
// VerifyES256 will return InvalidSignature if the JWT is malformed, uses any
// algorithm other than RS256, or is not signed with the private key that
// corresponds to the public key given.
func VerifyES256(pub *ecdsa.PublicKey, s []byte, v interface{}) error {
	claims, err := verify(algES256, s, func(data, sig []byte) error {
		if len(sig) != 64 {
			return ErrInvalidSignature
		}

		var sigR, sigS big.Int
		sigR.SetBytes(sig[:32])
		sigS.SetBytes(sig[32:])

		h := sha256.New()
		h.Write(data)

		if !ecdsa.Verify(pub, h.Sum(nil), &sigR, &sigS) {
			return ErrInvalidSignature
		}

		return nil
	})

	if err != nil {
		return err
	}

	return json.Unmarshal(claims, v)
}
